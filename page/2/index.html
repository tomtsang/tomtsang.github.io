<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>tomtsang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Tom Tsang">
  
  
  <meta name="description" content="Tom Tsang&apos;s Blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="tomtsang">
<meta property="og:url" content="http://tomtsang.github.io/page/2/index.html">
<meta property="og:site_name" content="tomtsang">
<meta property="og:description" content="Tom Tsang&apos;s Blogs">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tomtsang">
<meta name="twitter:description" content="Tom Tsang&apos;s Blogs">
  
    <link rel="alternate" href="/atom.xml" title="tomtsang" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
  

</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">tomtsang</a></h1>
    <p><a href="/">AI,BIGDATA,CODE,DATA,E,FINTECH ...</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/reading">Reading</a></li>
      
        <li><a href="/about">About</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/01/15/mac/">
  <time datetime="2017-01-15T04:41:12.000Z">
    2017-01-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/01/15/mac/">mac</a></h1>
  

  </header>
  
  <div class="entry">
    
      
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/12/14/hello-world/">
  <time datetime="2016-12-14T07:19:50.000Z">
    2016-12-14
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/12/14/hello-world/">Hello World</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/12/12/mysql-9/">
  <time datetime="2016-12-12T08:43:19.000Z">
    2016-12-12
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/12/12/mysql-9/">mysql系列之</a></h1>
  

  </header>
  
  <div class="entry">
    
      
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/12/12/docker-1/">
  <time datetime="2016-12-12T03:05:21.000Z">
    2016-12-12
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/12/12/docker-1/">docker系列之安装（centos）</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/centos/</a></p>
<h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><pre><code>[tom@mysql1 ~]$ sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-&apos;EOF&apos;
&gt; [dockerrepo]
&gt; name=Docker Repository
&gt; baseurl=https://yum.dockerproject.org/repo/main/centos/7/
&gt; enabled=1
&gt; gpgcheck=1
&gt; gpgkey=https://yum.dockerproject.org/gpg
&gt; EOF
[dockerrepo]
name=Docker Repository
baseurl=https://yum.dockerproject.org/repo/main/centos/7/
enabled=1
gpgcheck=1
gpgkey=https://yum.dockerproject.org/gpg
[tom@mysql1 ~]$ sudo yum install docker-engine -y
...
Installed:
  docker-engine.x86_64 0:1.12.3-1.el7.centos                                                                                                          

Dependency Installed:
  docker-engine-selinux.noarch 0:1.12.3-1.el7.centos                                                                                                  

Complete!
[tom@mysql1 ~]$ sudo systemctl enable docker.service
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
[tom@mysql1 ~]$ sudo systemctl start docker
[tom@mysql1 ~]$ sudo docker run --rm hello-world
Unable to find image &apos;hello-world:latest&apos; locally
latest: Pulling from library/hello-world
c04b14da8d14: Pull complete
Digest: sha256:0256e8a36e2070f7bf2d0b0763dbabdd67798512411de4cdcf9431a1feb60fd9
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker Hub account:
 https://hub.docker.com

For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/

[tom@mysql1 ~]$ sudo groupadd docker
groupadd: group &apos;docker&apos; already exists
[tom@mysql1 ~]$ sudo usermod -aG docker tom
</code></pre><h4 id="ctrl-v"><a href="#ctrl-v" class="headerlink" title="ctrl + v"></a>ctrl + v</h4><pre><code>[tom@mysql1 ~]$ sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-&apos;EOF&apos;
&gt; [dockerrepo]
&gt; name=Docker Repository
&gt; baseurl=https://yum.dockerproject.org/repo/main/centos/7/
&gt; enabled=1
&gt; gpgcheck=1
&gt; gpgkey=https://yum.dockerproject.org/gpg
&gt; EOF
[dockerrepo]
name=Docker Repository
baseurl=https://yum.dockerproject.org/repo/main/centos/7/
enabled=1
gpgcheck=1
gpgkey=https://yum.dockerproject.org/gpg
[tom@mysql1 ~]$ sudo yum install docker-engine -y
[tom@mysql1 ~]$ sudo systemctl enable docker.service
[tom@mysql1 ~]$ sudo systemctl start docker
[tom@mysql1 ~]$ sudo docker run --rm hello-world
[tom@mysql1 ~]$ sudo groupadd docker
[tom@mysql1 ~]$ sudo usermod -aG docker tom
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/12/01/gitlab-1/">
  <time datetime="2016-12-01T04:11:41.000Z">
    2016-12-01
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/12/01/gitlab-1/">gitlab系列之workflow</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>本文是 官方 workflow 的中文翻译</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.gitlab.com/ee/workflow/gitlab_flow.html" target="_blank" rel="external">https://docs.gitlab.com/ee/workflow/gitlab_flow.html</a></p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>使用git进行版本管理使得分支和合并比旧版本系统（如SVN）容易得多。 这允许多种分支策略和工作流程。 几乎所有这些都是对git之前使用的方法的改进。 但是许多组织最终没有明确定义，过于复杂或没有与问题跟踪系统（issue tracking systems）集成的，工作流。 因此，我们建议<code>GitLab flow</code>作为明确定义的一套最佳实践。 它结合了<code>功能驱动开发</code>和<code>功能分支</code>的问题跟踪。</p>
<p>来自其他版本控制系统的组织经常发现很难开发有效的工作流。 本文介绍“将git工作流与问题跟踪系统集成”的GitLab流程。 它提供了一个简单，透明和有效的方式使用git。</p>
<p><img src="https://docs.gitlab.com/ee/workflow/four_stages.png" alt="这里是个图片"></p>
<p>当转换到git时，你必须习惯于在与同事共享提交之前有三个步骤。 大多数版本控制系统只有一个步骤，从工作副本提交到共享服务器。 在git中，您可以将文件从工作副本添加到暂存区域。 之后，你提交他们到本地回购。 第三步是推送到共享远程存储库。 在习惯了这三个步骤之后，分支模型成为挑战。</p>
<p><img src="https://docs.gitlab.com/ee/workflow/messy_flow.png" alt="这里是个图片"></p>
<p>因为许多组织，对于git是新认识，没有公约如何使用它，那么很快git变成一团糟。 他们遇到的最大的问题是，许多长期运行的分支，每个包含了一部分的变化。 人们很难确定他们应该开发或部署到生产的是哪个分支。 通常对这个问题的反应是采用标准化模式，例如git流和GitHub流。 我们认为仍有改进的余地，并将详细介绍一组我们称为GitLab流程的做法。</p>
<h4 id="Git-flow-and-its-problems"><a href="#Git-flow-and-its-problems" class="headerlink" title="Git flow and its problems"></a>Git flow and its problems</h4><p><img src="https://docs.gitlab.com/ee/workflow/gitdashflow.png" alt="这里是个图片"></p>
<p>Git流是一个第一建议使用git分支的vcs，它得到了很多的关注。它主张一个主分支、一个单独开发分支以及支持特性功能开发，发布版本和修补程序的其它分支。开发发生在开发分支上，移动到发布分支，并最终合并到主分支。 Git流是有一个定义良好的标准，但它的复杂性引入了两个问题。第一个问题是开发人员必须使用develop分支而不是master，master是保留给用于发布生产版本的代码。这是一个约定，称默认分支为master，并主要从此master分支，合并到此master。由于大多数工具自动使master分支成为默认分支，并在默认情况下显示该分支，因此必须切换到另一个分支。git流的第二个问题是修补程序和发布分支引入的复杂性。这些分支对于一些组织来说可能是一个好主意，但对于绝大多数组织来说是过分了。现在大多数组织实施持续交付，这意味着可以部署您的默认master分支。这意味着要prevented修补程序和发布分支，包括它们引入的所有仪式（ceremony）。这个仪式的一个例子是合并发布分支。虽然存在专门的工具来解决这个问题，但它们需要文档并增加复杂性。开发人员经常犯错误，例如更改只会合并到master中，而不会合并到develop分支中。这些错误的根本原因是git流对于大多数用例来说太复杂了。并且发布并不自动意味着也做修补程序。</p>
<h4 id="GitHub-flow-as-a-simpler-alternative"><a href="#GitHub-flow-as-a-simpler-alternative" class="headerlink" title="GitHub flow as a simpler alternative"></a>GitHub flow as a simpler alternative</h4><p><img src="https://docs.gitlab.com/ee/workflow/github_flow.png" alt="这里是个图片"></p>
<p>在对git流的应对中，一个更简单的选择是，详细的GitHub流。 此流仅具有特征分支和master分支。 这是非常简单和干净，许多组织已经采用它与巨大的成功。 Atlassian推荐一个类似的策略，虽然他们rebase特征分支。 将所有内容合并到主分支并经常部署,意味着您最小化“库存”中的代码量，这符合精益和持续交付最佳实践。 但是这个流程仍然有许多关于部署，环境，发布和问题集成的问题。 使用GitLab流程，我们为这些问题提供额外的指导。</p>
<h4 id="Production-branch-with-GitLab-flow"><a href="#Production-branch-with-GitLab-flow" class="headerlink" title="Production branch with GitLab flow"></a>Production branch with GitLab flow</h4><p><img src="https://docs.gitlab.com/ee/workflow/production_branch.png" alt="这里是个图片"></p>
<p>GitHub流假设你能够在每次合并特性分支时都部署到生产环境。这对于SaaS应用程序是可能的，但在许多情况下，这是不可能的。一种情况是，你不能控制确切的发布时刻，例如需要通过App Store验证的iOS应用程序。另一个例子是，当您有部署窗口时间（工作日从上午10点到下午4点，当操作团队满员时），但您也可以在其他时间合并代码。在这些情况下，您可以创建一个反映部署代码的生产分支。您可以通过将master合并到生产（production）分支来部署新版本。如果你需要知道在生产分支中是什么代码，你可以只是checkout到生产分支看看。部署的大致时间，很容易显示为版本控制系统中的合并提交时间。如果您自动部署生产分支，这一时间是相当准确的。如果您需要更准确的时间，您可以让部署脚本在每个部署中创建一个tag。此流防止了，git流的发布，标记和合并的开销。</p>
<h4 id="Environment-branches-with-GitLab-flow"><a href="#Environment-branches-with-GitLab-flow" class="headerlink" title="Environment branches with GitLab flow"></a>Environment branches with GitLab flow</h4><p><img src="https://docs.gitlab.com/ee/workflow/environment_branches.png" alt="这里是个图片"></p>
<p>建立一个自动更新到master分支的环境可能是个好主意。只有在这种情况下，此环境的名称可能与分支名称不同。假设您有一个暂存环境（staging environment），一个预生产环境和一个生产环境。在这种情况下，主分支将部署在暂存环境。当有人想要部署到预生产时，他们创建从主分支到预生产分支的合并请求。并且通过合并预生产分支到生产分支。此工作流只提交下游流确保一切都已在所有环境中测试过。如果您需要使用修补程序选择一个提交，通常在特性分支上进行开发，并将其与合并请求合并到master中，不要删除特性分支。如果master是好的（它应该是好的，如果你是连续交付的），然后将它合并到其他分支（也就是合并到预生产环境和生产环境）。如果这是不可能的（因为可能需要更多的手动测试），您可以将功能分支的合并请求发送到下游分支。 环境分支的一个“极端”版本，就是，正在为Teatro所做的，每个功能分支设置一个环境。</p>
<h4 id="Release-branches-with-GitLab-flow"><a href="#Release-branches-with-GitLab-flow" class="headerlink" title="Release branches with GitLab flow"></a>Release branches with GitLab flow</h4><p><img src="https://docs.gitlab.com/ee/workflow/release_branches.png" alt="这里是个图片"></p>
<p>只有在需要将软件发布到外部世界的情况下，您才需要使用版本发布分支。在这种情况下，每个分支包含次要版本（2-3稳定版，2-4稳定版等）。稳定分支使用master作为起点，并尽可能晚地创建。通过尽可能晚的提交分支，您必须将错误修复应用到多个分支的时间最小化。在发布了一个发布分支后，只有严重的错误修复包括在发布分支中。如果可能的话，这些错误修复首先合并到master中，然后进入发布分支。这种方式下，你不能忘记cherry-picked他们进 master 和 遇到相同的bug的后续版本。这称为“上游第一”策略，也是由Google和Red Hat实施的。每次在发布分支中包括错误修复时，通过设置新标签来提高补丁版本（以符合语义版本控制）。一些项目也有一个稳定的分支，指向与最新发布的分支相同的提交。在这个流程中，有一个生产分支（或git flow master分支）是不常见的。</p>
<h4 id="Merge-pull-requests-with-GitLab-flow"><a href="#Merge-pull-requests-with-GitLab-flow" class="headerlink" title="Merge/pull requests with GitLab flow"></a>Merge/pull requests with GitLab flow</h4><p><img src="https://docs.gitlab.com/ee/workflow/mr_inline_comments.png" alt="这里是个图片"></p>
<p>合并或拉取请求在git管理应用程序中创建，并要求分配任务的人合并两个分支。诸如GitHub和Bitbucket之类的工具选择名称为拉动请求（pull request），因为第一个手动动作将是拉取pull特征分支。诸如GitLab和其他工具之类的工具选择名称为合并请求（merge request），因为最终动作是请求代理人的动作。在本文中，我们将它们称为合并请求。</p>
<p>如果你在一个功能分支上工作超过几个小时，最好与团队的其他成员分享中间结果。这可以通过创建合并请求（而不是将任务分配给任何人，相应地，你在（描述或注释中）提醒其他人），来完成。这意味着它还没有准备好被合并，但欢迎反馈。您的团队成员可以对一般的合并请求或具有行注释的特定行，发表评论。合并请求作为代码审查工具，不需要单独的工具，如Gerrit和reviewboard。如果审查揭示了缺点（shortcomings），任何人可以提交和推动修复。通常，这样做的人，是合并/拉取请求的创建者。当在分支上推送新提交时，merge / pull请求中的diff会自动更新。</p>
<p>当你觉得合并它的时候，你可以把它分配给那些最了解你正在改变的代码库的人，并提及 你希望从任何其他人那里得到反馈的人员名单。有更多的反馈空间，在分配的人员后，进行分支合并的结果，会让人感到舒适。如果被分配的人不舒服，他们可以关闭合并请求而不合并。</p>
<p>在GitLab中，通常保护长期分支（例如master分支），以便正常的开发人员不能修改这些受保护的分支。所以如果你想把它合并到一个受保护的分支，你可以将它分配给有master权限的人。</p>
<h4 id="Issues-with-GitLab-flow"><a href="#Issues-with-GitLab-flow" class="headerlink" title="Issues with GitLab flow"></a>Issues with GitLab flow</h4><p><img src="https://docs.gitlab.com/ee/workflow/merge_request.png" alt="这里是个图片"></p>
<p>GitLab流是一种使代码和问题跟踪之间的关系更透明的方式。</p>
<p>代码的任何重大更改应从描述目标的问题（issue）开始。每个代码更改的原因是重要的通知团队中的每个人，并帮助人们保持功能分支的范围小。在GitLab中，对代码库的每个更改都从问题跟踪系统中的问题开始。如果有重大的工作被涉及（超过1小时），即使没有issue，那也应该首先创建issue。对于许多组织，这将是自然的，因为问题（issue）将必须被估计。问题标题应该描述系统的期望状态，例如“作为管理员，我要删除用户, 而不是收到一个error”，而不是“管理员无法删除用户”。</p>
<p>当您准备好编码时，从master分支启动一个问题分支。此分支的名称应以问题编号开头，例如’15 -require-a-password-to-change-it’。</p>
<p>当你完成代码了或者当你想讨论代码时，你要打开一个合并请求。这是一个在线的地方，用于讨论这次更改，并且审查代码。打开合并请求是手动操作，因为您不是总想合并您推送的新分支，它可能是长期运行的环境或发布分支。如果打开合并请求，但没有将其分配给任何人，则它是一个处于“正在进行（Work In Progress）”状态的合并请求。这些用于讨论某些建议的实现，但尚未准备好纳入master分支中。专家提示：合并请求的标题使用[WIP]或WIP作为开始，以防止合并请求在准备就绪之前被合并了。</p>
<p>当作者认为代码就绪时，合并请求将分配给审阅者（reviewer）。当审阅者认为代码准备放进在master分支中时，就按下合并按钮。在这种情况下，代码被合并，并生成合并提交，使此事件后来很容易可见。合并请求总是创建一个合并提交，即使当commit可以被添加(added)，但是没有一个提交。这个合并策略在git中称为“no fast-forward”。合并后，特征分支被删除，因为它不再需要。在GitLab中，这种删除动作在合并时，是可选的。</p>
<p>假设分支被合并，但是在这合并后又发现一个新问题，那就重新打开这个问题。在这种情况下，重用相同的分支名称是没有问题的，因为当合并分支时它被删除。任何时候，每个问题最多只有一个分支。一个特征分支可能解决多个问题。</p>
<h4 id="Linking-and-closing-issues-from-merge-requests"><a href="#Linking-and-closing-issues-from-merge-requests" class="headerlink" title="Linking and closing issues from merge requests"></a>Linking and closing issues from merge requests</h4><p><img src="https://docs.gitlab.com/ee/workflow/close_issue_mr.png" alt="这里是个图片"></p>
<p>链接到问题（issue）会在下面这个情况下发生：在提交消息（修复＃14，关闭＃67等）中提及，或从合并请求描述中提及。 合并请求提及问题（issue）的情况，在GitLab中，会在这个issue中，创建一个注解。 并且合并请求会显示这个linked issues。 一旦代码合并到默认分支中，这些问题就会关闭。</p>
<p>如果你只想参考没有关闭的issue，你也可以提到它：“Duck typing是首选。＃12”。</p>
<p>如果您有跨多个存储库的问题，最好的办法是为每个存储库创建一个问题，并将所有问题链接到父问题(parent issue)。</p>
<h4 id="Squashing-commits-with-rebase"><a href="#Squashing-commits-with-rebase" class="headerlink" title="Squashing commits with rebase"></a>Squashing commits with rebase</h4><p><img src="https://docs.gitlab.com/ee/workflow/rebase.png" alt="这里是个图片"></p>
<p>使用git，您可以使用交互式rebase（rebase -i）将多个提交压缩成一个并重新排序。在GitLab EE和.com中，您还可以在Web界面合并之前进行rebase。如果您在开发过程中进行了一些小的更改，并希望用单个提交替换它们，或者想要使顺序更具逻辑性，则此功能非常有用。然而，你不应该rebase提交推送到远程服务器。有人可以参考提交或樱桃选择他们。当你rebase时，你改变提交的标识符（SHA-1），这是令人困惑的。如果你这样做，相同的更改将在多个标识符下，这可能会导致很多混乱。如果人们已经审查你的代码，他们将很难仅仅审查自那时以来由你所做的改进，如果你已经rebased 一切修改为一个提交。不要rebase的另一个原因是，你失去了作者信息，也许有人创建了一个合并请求，另一个人推送一个提交，以改善它，第三个合并它。在这种情况下，将所有提交重新映射为一个，以防止其他作者，被正确归因和共享一部分git blame。</p>
<p>鼓励人们经常提交，并经常推送到远程存储库，以便其他人知道每个人都在做什么。这将导致每个更改的许多提交，这使得历史更难以理解。但是具有稳定的标识符（stable identifiers）的优点胜过这个缺点。为了理解上下文中的变化，可以总是去看合并提交，因为当代码合并到master分支时会将所有提交被分组在一起。</p>
<p>将特性分支的多个提交合并到主分支后，这更难撤消。如果你将所有的提交压缩成一个你可以刚刚恢复这个提交，但正如我们所指出的，你不应该在提交后重做提交。幸运的是，还原在一段时间以前的合并，是可以用git完成的。但是，这需要对您要恢复的提交，进行一个特定合并提交（specific merge commits）。如果你还原合并，你又改变主意，那么你要恢复这次还原（而不是再次合并），因为git将不允许你再次合并代码。</p>
<p>能够还原合并（revert a merge）是一个很好的原因，当您手动用–no-ff选项合并时，始终创建合并提交。当您接受合并请求时，Git管理软件将始终创建合并提交。</p>
<h4 id="Do-not-order-commits-with-rebase"><a href="#Do-not-order-commits-with-rebase" class="headerlink" title="Do not order commits with rebase"></a>Do not order commits with rebase</h4><p><img src="https://docs.gitlab.com/ee/workflow/merge_commits.png" alt="这里是个图片"></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/12/01/gitlab/">
  <time datetime="2016-12-01T04:11:33.000Z">
    2016-12-01
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/12/01/gitlab/">gitlab系列之</a></h1>
  

  </header>
  
  <div class="entry">
    
      
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/11/30/nodejs-2/">
  <time datetime="2016-11-30T06:18:32.000Z">
    2016-11-30
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/11/30/nodejs-2/">nodejs系列之npm报错</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h4 id="报错1，permission-denied-open-39-usr-local-lib-node-modules-npm-lib"><a href="#报错1，permission-denied-open-39-usr-local-lib-node-modules-npm-lib" class="headerlink" title="报错1，permission denied, open &#39;/usr/local/lib/node_modules/npm/lib/"></a>报错1，<code>permission denied, open &#39;/usr/local/lib/node_modules/npm/lib/</code></h4><pre><code>tom@adata:~/in/ttt$ npm i
npm ERR! Linux 4.4.0-47-generic
npm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;i&quot;
npm ERR! node v6.9.1
npm ERR! npm  v3.10.8
npm ERR! path /usr/local/lib/node_modules/npm/lib/fetch-package-metadata.js
npm ERR! code EACCES
npm ERR! errno -13
npm ERR! syscall open

npm ERR! Error: EACCES: permission denied, open &apos;/usr/local/lib/node_modules/npm/lib/fetch-package-metadata.js&apos;
npm ERR!     at Error (native)
npm ERR!     at Object.fs.openSync (fs.js:640:18)
npm ERR!     at Object.fs.readFileSync (fs.js:508:33)
npm ERR!     at Object.Module._extensions..js (module.js:578:20)
npm ERR!     at Module.load (module.js:487:32)
npm ERR!     at tryModuleLoad (module.js:446:12)
npm ERR!     at Function.Module._load (module.js:438:3)
npm ERR!     at Module.require (module.js:497:17)
npm ERR!     at require (internal/module.js:20:19)
npm ERR!     at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/npm/lib/install/deps.js:15:28)
npm ERR!  { Error: EACCES: permission denied, open &apos;/usr/local/lib/node_modules/npm/lib/fetch-package-metadata.js&apos;
npm ERR!     at Error (native)
npm ERR!     at Object.fs.openSync (fs.js:640:18)
npm ERR!     at Object.fs.readFileSync (fs.js:508:33)
npm ERR!     at Object.Module._extensions..js (module.js:578:20)
npm ERR!     at Module.load (module.js:487:32)
npm ERR!     at tryModuleLoad (module.js:446:12)
npm ERR!     at Function.Module._load (module.js:438:3)
npm ERR!     at Module.require (module.js:497:17)
npm ERR!     at require (internal/module.js:20:19)
npm ERR!     at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/npm/lib/install/deps.js:15:28)
npm ERR!   errno: -13,
npm ERR!   code: &apos;EACCES&apos;,
npm ERR!   syscall: &apos;open&apos;,
npm ERR!   path: &apos;/usr/local/lib/node_modules/npm/lib/fetch-package-metadata.js&apos; }
npm ERR!
npm ERR! Please try running this command again as root/Administrator.

npm ERR! Please include the following file with any support request:
npm ERR!     /home/tom/in/ttt/npm-debug.log
tom@adata:~/in/ttt$_
</code></pre><p>解决：</p>
<p>先查node，npm版本</p>
<pre><code>tom@adata:~/in/ttt$ node -v
v6.9.1
tom@adata:~/in/ttt$ ls -l /usr/local/sbin/bin/n*
ls: cannot access &apos;/usr/local/sbin/bin/n*&apos;: No such file or directory
tom@adata:~/in/ttt$ which node
/usr/local/bin/node
tom@adata:~/in/ttt$ ls -l /usr/local/bin/n*
-rwxr-xr-x 1 root root 30194989 11月 24 09:45 /usr/local/bin/node
lrwxrwxrwx 1 root root       38 11月 24 09:45 /usr/local/bin/npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js
tom@adata:~/in/ttt$
</code></pre><p>发现，npm是一个软链接，所以，可能问题出在这里，这样呢，我们更新一下 npm 本身吧。<code>sudo npm i npm -g</code>。走起。</p>
<pre><code>tom@adata:~/in/ttt$ sudo npm i npm -g
[sudo] password for tom:
/usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.js
- retry@0.10.0 node_modules/npm/node_modules/npm-registry-client/node_modules/retry
- core-util-is@1.0.2 node_modules/npm/node_modules/request/node_modules/bl/node_modules/readable-stream/node_modules/core-util-is
- isarray@1.0.0 node_modules/npm/node_modules/request/node_modules/bl/node_modules/readable-stream/node_modules/isarray
- process-nextick-args@1.0.7 node_modules/npm/node_modules/request/node_modules/bl/node_modules/readable-stream/node_modules/process-nextick-args
- string_decoder@0.10.31 node_modules/npm/node_modules/request/node_modules/bl/node_modules/readable-stream/node_modules/string_decoder
- util-deprecate@1.0.2 node_modules/npm/node_modules/request/node_modules/bl/node_modules/readable-stream/node_modules/util-deprecate
- readable-stream@2.0.6 node_modules/npm/node_modules/request/node_modules/bl/node_modules/readable-stream
- bl@1.1.2 node_modules/npm/node_modules/request/node_modules/bl
- async@1.5.2 node_modules/npm/node_modules/request/node_modules/form-data/node_modules/async
/usr/local/lib
└─┬ npm@4.0.2
  ├── asap@2.0.5
  ├── config-chain@1.1.11
...
...
...
tom@adata:~/in/ttt$
</code></pre><p>我们重新再尝试吧。</p>
<pre><code>tom@adata:~/in/ttt$ ls
package.json
tom@adata:~/in/ttt$ npm i
openQuote2@2.0.0 /home/tom/in/ttt
├── async@1.5.2
├─┬ mongodb@2.2.12
│ ├── es6-promise@3.2.1
│ ├─┬ mongodb-core@2.0.14
│ │ ├── bson@0.5.7
│ │ └─┬ require_optional@1.0.0
│ │   ├── resolve-from@2.0.0
│ │   └── semver@5.3.0
│ └─┬ readable-stream@2.1.5
│   ├── buffer-shims@1.0.0
│   ├── core-util-is@1.0.2
│   ├── inherits@2.0.3
│   ├── isarray@1.0.0
│   ├── process-nextick-args@1.0.7
│   ├── string_decoder@0.10.31
│   └── util-deprecate@1.0.2
└─┬ mysql@2.12.0
  ├── bignumber.js@2.4.0
  ├─┬ readable-stream@1.1.14
  │ └── isarray@0.0.1
  └── sqlstring@2.2.0

tom@adata:~/in/ttt$
</code></pre><p>好了，成功了。<br>但是，我重新再去查</p>
<pre><code>tom@adata:~/in/ttt$ which npm
/usr/local/bin/npm
tom@adata:~/in/ttt$ which node
/usr/local/bin/node
tom@adata:~/in/ttt$ ls -l /usr/local/bin/n*
-rwxr-xr-x 1 root root 30194989 11月 24 09:45 /usr/local/bin/node
lrwxrwxrwx 1 root root       38 11月 24 09:45 /usr/local/bin/npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js
tom@adata:~/in/ttt$
tom@adata:~/in/ttt$ npm -v
4.0.2
tom@adata:~/in/ttt$
</code></pre><p>发现只更新了 npm 的版本，而已呀。看来，升级npm，才是解决这个问题的关键。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/11/30/nodejs-1/">
  <time datetime="2016-11-30T06:03:20.000Z">
    2016-11-30
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/11/30/nodejs-1/">nodejs系列之mongodb</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>var mongodb = require(“mongodb”);</p>
<p>这个 mongodb 包的API文档：</p>
<p><a href="http://mongodb.github.io/node-mongodb-native/2.2/api/index.html" target="_blank" rel="external">http://mongodb.github.io/node-mongodb-native/2.2/api/index.html</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/11/29/mongodb-3/">
  <time datetime="2016-11-29T10:22:28.000Z">
    2016-11-29
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/11/29/mongodb-3/">mongodb系列之update</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>只要是批量，后头加 <code>{multi: true}</code> 吧。</p>
<h2 id="批量，新增一个k-v"><a href="#批量，新增一个k-v" class="headerlink" title="批量，新增一个k-v"></a>批量，新增一个k-v</h2><p>db.Signals_Day.update({TrdDt:20161129}, {$set: {“Real”: true}}, {multi: true})</p>
<pre><code>testrs:PRIMARY&gt; db.Signals_Day.update({TrdDt:20161129}, {$set: {&quot;Real&quot;: true}}, {multi: true})
WriteResult({ &quot;nMatched&quot; : 8935, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 8933 })
testrs:PRIMARY&gt; db.Signals_Day.find({TrdDt:20161129})
{ &quot;_id&quot; : ObjectId(&quot;583d27735868c24cb078e925&quot;), &quot;Type&quot; : &quot;NewHighLow&quot;, &quot;Sign&quot; : -1, &quot;ID&quot; : &quot;000785.SZ&quot;, &quot;TrdDt&quot; : 20161129, &quot;TrdTm&quot; : 1500, &quot;PrevClsPx&quot; : 14.99, &quot;LastPx&quot; : 14.4, &quot;Real&quot; : true }
{ &quot;_id&quot; : ObjectId(&quot;583d27735868c24cb078e92a&quot;), &quot;Type&quot; : &quot;RSI&quot;, &quot;Sign&quot; : -1, &quot;ID&quot; : &quot;002117.SZ&quot;, &quot;TrdDt&quot; : 20161129, &quot;TrdTm&quot; : 1500, &quot;PrevClsPx&quot; : 29.88, &quot;LastPx&quot; : 29.84, &quot;Real&quot; : true }
Type &quot;it&quot; for more
testrs:PRIMARY&gt;_
</code></pre><h2 id="批量，修改一个key的value-原value乘以100"><a href="#批量，修改一个key的value-原value乘以100" class="headerlink" title="批量，修改一个key的value, 原value乘以100"></a>批量，修改一个key的value, 原value乘以100</h2><p>db.Signals_Day.update({TrdDt:20161129}, {$mul: {“TrdTm”:100}}, {multi: true} )</p>
<pre><code>testrs:PRIMARY&gt; db.Signals_Day.update({TrdDt:20161129}, {$mul: {&quot;TrdTm&quot;:100}}, {multi: true} )
WriteResult({ &quot;nMatched&quot; : 8935, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 8935 })
testrs:PRIMARY&gt; db.Signals_Day.find({TrdDt:20161129})
</code></pre><p>##</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/11/29/linux-2/">
  <time datetime="2016-11-29T03:13:01.000Z">
    2016-11-29
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/11/29/linux-2/">linux系列之端口与进程</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="linux如何查看端口被哪个进程占用"><a href="#linux如何查看端口被哪个进程占用" class="headerlink" title="linux如何查看端口被哪个进程占用"></a>linux如何查看端口被哪个进程占用</h2><p>使用netstat 和lsof命令，并用grep来过滤你需要查看的端口。<br>例如查看tcp有哪些端口打开了：</p>
<pre><code>netstat -a| grep tcp
</code></pre><p>然后查看哪个进程占用了这些端口：</p>
<pre><code>lsof -i
</code></pre><p>如果要查看某个端口，比如80端口是哪个进程：</p>
<pre><code>lsof -i | grep :80
</code></pre><p>如果说，tom用户查到了一些端口号被占用，但是，用lsof却查不到。怎么办？<br>则要考虑，是不是端口被root用户占用，没有权限。所以要再一次用sudo lsof来查一查。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>netstat -ant | grep 8060
ps -aux | grep node
lsof -i:8060
man lsof
lsof  -i
lsof  -i -n
lsof -iTCP
sudo lsof -i
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
    <a href="/" class="prev">Prev</a>
  
  
    <a href="/page/3/" class="next">Next</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">Tom Tsang</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>